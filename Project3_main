#include <linux/kernel.h>
#include <linux/hrtimer.h>
#include <linux/ktime.h>
#include <linux/mm.h>
#include <linux/sched/mm.h>
#include <linux/module.h>

#define TIMER_INTERVAL_NS 10000000000ULL // 10 seconds in nanoseconds

static struct hrtimer hr_timer;
static int pid;
static unsigned long rss_count = 0;
static unsigned long wss_count = 0;
static unsigned long swap_count = 0;

// Callback function for the timer to measure memory usage
enum hrtimer_restart timer_callback(struct hrtimer *timer) {
    struct task_struct *task;
    struct mm_struct *mm;
    struct vm_area_struct *vma;
    unsigned long address;

    task = pid_task(find_vpid(pid), PIDTYPE_PID);
    if (!task) {
        printk(KERN_INFO "Process with PID %d not found\n", pid);
        return HRTIMER_NORESTART;
    }

    mm = task->mm;
    if (!mm) {
        printk(KERN_INFO "Process MM not accessible for PID %d\n", pid);
        return HRTIMER_NORESTART;
    }

    rss_count = 0;
    wss_count = 0;
    swap_count = 0;

    // Traverse VMAs and walk through memory pages
    for (vma = mm->mmap; vma; vma = vma->vm_next) {
        for (address = vma->vm_start; address < vma->vm_end; address += PAGE_SIZE) {
            pte_t *ptep, pte;
            spinlock_t *ptl;

            ptep = lookup_address(address, 0);
            if (ptep) {
                pte = *ptep;
                spin_lock(ptl);
                if (pte_present(pte)) {
                    rss_count++;
                    if (pte_young(pte)) {
                        wss_count++;
                        pte = pte_mkold(pte); // Mark as not recently used
                        set_pte_at(mm, address, ptep, pte);
                    }
                } else {
                    swap_count++;
                }
                spin_unlock(ptl);
            }
        }
    }

    // Log memory usage statistics
    printk(KERN_INFO "PID %d: RSS=%lu KB, SWAP=%lu KB, WSS=%lu KB\n", pid,
           (rss_count * PAGE_SIZE) / 1024, (swap_count * PAGE_SIZE) / 1024,
           (wss_count * PAGE_SIZE) / 1024);

    return HRTIMER_RESTART;
}

static int __init timer_init(void) {
    ktime_t ktime;
    pid = 1234; // Replace with the PID you want to monitor

    ktime = ktime_set(0, TIMER_INTERVAL_NS);
    hrtimer_init(&hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
    hr_timer.function = &timer_callback;

    hrtimer_start(&hr_timer, ktime, HRTIMER_MODE_REL);

    return 0;
}

static void __exit timer_exit(void) {
    hrtimer_cancel(&hr_timer);
    printk(KERN_INFO "HR Timer module exiting\n");
}

module_init(timer_init);
module_exit(timer_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
